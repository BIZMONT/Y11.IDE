//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.1 D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g 2015-02-18 10:57:56

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Y11
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.1")]
[System.CLSCompliant(false)]
public partial class Y11Lexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int AND=4;
	public const int BECOMES=5;
	public const int COM=6;
	public const int COMMENT=7;
	public const int DIGIT=8;
	public const int DIV=9;
	public const int EQL=10;
	public const int GEQ=11;
	public const int GET=12;
	public const int ID=13;
	public const int LEQ=14;
	public const int LETTER=15;
	public const int LETTERL=16;
	public const int LPAREN=17;
	public const int MINUS=18;
	public const int MOD=19;
	public const int MUL=20;
	public const int NAME=21;
	public const int NEQ=22;
	public const int NOT=23;
	public const int NUMBER=24;
	public const int OR=25;
	public const int PLUS=26;
	public const int PROG=27;
	public const int PUT=28;
	public const int QUOTE=29;
	public const int REP=30;
	public const int RPAREN=31;
	public const int SEMI=32;
	public const int START=33;
	public const int STOP=34;
	public const int STRING=35;
	public const int UNT=36;
	public const int VAR=37;
	public const int WS=38;

	// delegates
	// delegators

	public Y11Lexer()
	{
		OnCreated();
	}

	public Y11Lexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public Y11Lexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 1);
		TraceIn("PLUS", 1);
        try
        {
            int _type = PLUS;
            int _channel = DefaultTokenChannel;
            // D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:13:9: ( '+' )
            DebugEnterAlt(1);
            // D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:13:11: '+'
            {
                DebugLocation(13, 11);
                Match('+');

            }

            state.type = _type;
            state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("PLUS", 1);
			LeaveRule("PLUS", 1);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 2);
		TraceIn("MINUS", 2);
		try
		{
			int _type = MINUS;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:14:8: ( '-' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:14:10: '-'
			{
			DebugLocation(14, 10);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("MINUS", 2);
			LeaveRule("MINUS", 2);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_MUL();
	partial void LeaveRule_MUL();

	// $ANTLR start "MUL"
	[GrammarRule("MUL")]
	private void mMUL()
	{
		EnterRule_MUL();
		EnterRule("MUL", 3);
		TraceIn("MUL", 3);
		try
		{
			int _type = MUL;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:15:5: ( '*' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:15:7: '*'
			{
			DebugLocation(15, 7);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("MUL", 3);
			LeaveRule("MUL", 3);
			LeaveRule_MUL();
		}
	}
	// $ANTLR end "MUL"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 4);
		TraceIn("LPAREN", 4);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:16:8: ( '(' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:16:10: '('
			{
			DebugLocation(16, 10);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("LPAREN", 4);
			LeaveRule("LPAREN", 4);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 5);
		TraceIn("RPAREN", 5);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:17:8: ( ')' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:17:10: ')'
			{
			DebugLocation(17, 10);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("RPAREN", 5);
			LeaveRule("RPAREN", 5);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_SEMI();
	partial void LeaveRule_SEMI();

	// $ANTLR start "SEMI"
	[GrammarRule("SEMI")]
	private void mSEMI()
	{
		EnterRule_SEMI();
		EnterRule("SEMI", 6);
		TraceIn("SEMI", 6);
		try
		{
			int _type = SEMI;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:18:6: ( ';' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:18:8: ';'
			{
			DebugLocation(18, 8);
			Match(';'); 

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("SEMI", 6);
			LeaveRule("SEMI", 6);
			LeaveRule_SEMI();
		}
	}
	// $ANTLR end "SEMI"

	partial void EnterRule_BECOMES();
	partial void LeaveRule_BECOMES();

	// $ANTLR start "BECOMES"
	[GrammarRule("BECOMES")]
	private void mBECOMES()
	{
		EnterRule_BECOMES();
		EnterRule("BECOMES", 7);
		TraceIn("BECOMES", 7);
		try
		{
			int _type = BECOMES;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:19:9: ( '::=' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:19:11: '::='
			{
			DebugLocation(19, 11);
			Match("::="); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("BECOMES", 7);
			LeaveRule("BECOMES", 7);
			LeaveRule_BECOMES();
		}
	}
	// $ANTLR end "BECOMES"

	partial void EnterRule_EQL();
	partial void LeaveRule_EQL();

	// $ANTLR start "EQL"
	[GrammarRule("EQL")]
	private void mEQL()
	{
		EnterRule_EQL();
		EnterRule("EQL", 8);
		TraceIn("EQL", 8);
		try
		{
			int _type = EQL;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:20:5: ( '==' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:20:7: '=='
			{
			DebugLocation(20, 7);
			Match("=="); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("EQL", 8);
			LeaveRule("EQL", 8);
			LeaveRule_EQL();
		}
	}
	// $ANTLR end "EQL"

	partial void EnterRule_NEQ();
	partial void LeaveRule_NEQ();

	// $ANTLR start "NEQ"
	[GrammarRule("NEQ")]
	private void mNEQ()
	{
		EnterRule_NEQ();
		EnterRule("NEQ", 9);
		TraceIn("NEQ", 9);
		try
		{
			int _type = NEQ;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:21:5: ( '<>' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:21:7: '<>'
			{
			DebugLocation(21, 7);
			Match("<>"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("NEQ", 9);
			LeaveRule("NEQ", 9);
			LeaveRule_NEQ();
		}
	}
	// $ANTLR end "NEQ"

	partial void EnterRule_LEQ();
	partial void LeaveRule_LEQ();

	// $ANTLR start "LEQ"
	[GrammarRule("LEQ")]
	private void mLEQ()
	{
		EnterRule_LEQ();
		EnterRule("LEQ", 10);
		TraceIn("LEQ", 10);
		try
		{
			int _type = LEQ;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:22:5: ( '<=' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:22:7: '<='
			{
			DebugLocation(22, 7);
			Match("<="); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("LEQ", 10);
			LeaveRule("LEQ", 10);
			LeaveRule_LEQ();
		}
	}
	// $ANTLR end "LEQ"

	partial void EnterRule_GEQ();
	partial void LeaveRule_GEQ();

	// $ANTLR start "GEQ"
	[GrammarRule("GEQ")]
	private void mGEQ()
	{
		EnterRule_GEQ();
		EnterRule("GEQ", 11);
		TraceIn("GEQ", 11);
		try
		{
			int _type = GEQ;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:23:5: ( '>=' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:23:7: '>='
			{
			DebugLocation(23, 7);
			Match(">="); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("GEQ", 11);
			LeaveRule("GEQ", 11);
			LeaveRule_GEQ();
		}
	}
	// $ANTLR end "GEQ"

	partial void EnterRule_COM();
	partial void LeaveRule_COM();

	// $ANTLR start "COM"
	[GrammarRule("COM")]
	private void mCOM()
	{
		EnterRule_COM();
		EnterRule("COM", 12);
		TraceIn("COM", 12);
		try
		{
			int _type = COM;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:24:5: ( ',' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:24:7: ','
			{
			DebugLocation(24, 7);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("COM", 12);
			LeaveRule("COM", 12);
			LeaveRule_COM();
		}
	}
	// $ANTLR end "COM"

	partial void EnterRule_QUOTE();
	partial void LeaveRule_QUOTE();

	// $ANTLR start "QUOTE"
	[GrammarRule("QUOTE")]
	private void mQUOTE()
	{
		EnterRule_QUOTE();
		EnterRule("QUOTE", 13);
		TraceIn("QUOTE", 13);
		try
		{
			int _type = QUOTE;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:25:7: ( '\"' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:25:9: '\"'
			{
			DebugLocation(25, 9);
			Match('\"'); 

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("QUOTE", 13);
			LeaveRule("QUOTE", 13);
			LeaveRule_QUOTE();
		}
	}
	// $ANTLR end "QUOTE"

	partial void EnterRule_PROG();
	partial void LeaveRule_PROG();

	// $ANTLR start "PROG"
	[GrammarRule("PROG")]
	private void mPROG()
	{
		EnterRule_PROG();
		EnterRule("PROG", 14);
		TraceIn("PROG", 14);
		try
		{
			int _type = PROG;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:28:6: ( '#PROGRAM' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:28:8: '#PROGRAM'
			{
			DebugLocation(28, 8);
			Match("#PROGRAM"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("PROG", 14);
			LeaveRule("PROG", 14);
			LeaveRule_PROG();
		}
	}
	// $ANTLR end "PROG"

	partial void EnterRule_START();
	partial void LeaveRule_START();

	// $ANTLR start "START"
	[GrammarRule("START")]
	private void mSTART()
	{
		EnterRule_START();
		EnterRule("START", 15);
		TraceIn("START", 15);
		try
		{
			int _type = START;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:29:7: ( 'START' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:29:9: 'START'
			{
			DebugLocation(29, 9);
			Match("START"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("START", 15);
			LeaveRule("START", 15);
			LeaveRule_START();
		}
	}
	// $ANTLR end "START"

	partial void EnterRule_VAR();
	partial void LeaveRule_VAR();

	// $ANTLR start "VAR"
	[GrammarRule("VAR")]
	private void mVAR()
	{
		EnterRule_VAR();
		EnterRule("VAR", 16);
		TraceIn("VAR", 16);
		try
		{
			int _type = VAR;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:30:9: ( 'VARIABLE' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:30:17: 'VARIABLE'
			{
			DebugLocation(30, 17);
			Match("VARIABLE"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("VAR", 16);
			LeaveRule("VAR", 16);
			LeaveRule_VAR();
		}
	}
	// $ANTLR end "VAR"

	partial void EnterRule_STOP();
	partial void LeaveRule_STOP();

	// $ANTLR start "STOP"
	[GrammarRule("STOP")]
	private void mSTOP()
	{
		EnterRule_STOP();
		EnterRule("STOP", 17);
		TraceIn("STOP", 17);
		try
		{
			int _type = STOP;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:31:6: ( 'STOP' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:31:8: 'STOP'
			{
			DebugLocation(31, 8);
			Match("STOP"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("STOP", 17);
			LeaveRule("STOP", 17);
			LeaveRule_STOP();
		}
	}
	// $ANTLR end "STOP"

	partial void EnterRule_GET();
	partial void LeaveRule_GET();

	// $ANTLR start "GET"
	[GrammarRule("GET")]
	private void mGET()
	{
		EnterRule_GET();
		EnterRule("GET", 18);
		TraceIn("GET", 18);
		try
		{
			int _type = GET;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:32:5: ( 'GET' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:32:7: 'GET'
			{
			DebugLocation(32, 7);
			Match("GET"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("GET", 18);
			LeaveRule("GET", 18);
			LeaveRule_GET();
		}
	}
	// $ANTLR end "GET"

	partial void EnterRule_PUT();
	partial void LeaveRule_PUT();

	// $ANTLR start "PUT"
	[GrammarRule("PUT")]
	private void mPUT()
	{
		EnterRule_PUT();
		EnterRule("PUT", 19);
		TraceIn("PUT", 19);
		try
		{
			int _type = PUT;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:33:5: ( 'PUT' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:33:7: 'PUT'
			{
			DebugLocation(33, 7);
			Match("PUT"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("PUT", 19);
			LeaveRule("PUT", 19);
			LeaveRule_PUT();
		}
	}
	// $ANTLR end "PUT"

	partial void EnterRule_REP();
	partial void LeaveRule_REP();

	// $ANTLR start "REP"
	[GrammarRule("REP")]
	private void mREP()
	{
		EnterRule_REP();
		EnterRule("REP", 20);
		TraceIn("REP", 20);
		try
		{
			int _type = REP;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:34:5: ( 'REPEAT' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:34:7: 'REPEAT'
			{
			DebugLocation(34, 7);
			Match("REPEAT"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("REP", 20);
			LeaveRule("REP", 20);
			LeaveRule_REP();
		}
	}
	// $ANTLR end "REP"

	partial void EnterRule_UNT();
	partial void LeaveRule_UNT();

	// $ANTLR start "UNT"
	[GrammarRule("UNT")]
	private void mUNT()
	{
		EnterRule_UNT();
		EnterRule("UNT", 21);
		TraceIn("UNT", 21);
		try
		{
			int _type = UNT;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:35:5: ( 'UNTIL' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:35:7: 'UNTIL'
			{
			DebugLocation(35, 7);
			Match("UNTIL"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("UNT", 21);
			LeaveRule("UNT", 21);
			LeaveRule_UNT();
		}
	}
	// $ANTLR end "UNT"

	partial void EnterRule_DIV();
	partial void LeaveRule_DIV();

	// $ANTLR start "DIV"
	[GrammarRule("DIV")]
	private void mDIV()
	{
		EnterRule_DIV();
		EnterRule("DIV", 22);
		TraceIn("DIV", 22);
		try
		{
			int _type = DIV;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:36:5: ( 'DIV' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:36:7: 'DIV'
			{
			DebugLocation(36, 7);
			Match("DIV"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("DIV", 22);
			LeaveRule("DIV", 22);
			LeaveRule_DIV();
		}
	}
	// $ANTLR end "DIV"

	partial void EnterRule_MOD();
	partial void LeaveRule_MOD();

	// $ANTLR start "MOD"
	[GrammarRule("MOD")]
	private void mMOD()
	{
		EnterRule_MOD();
		EnterRule("MOD", 23);
		TraceIn("MOD", 23);
		try
		{
			int _type = MOD;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:37:5: ( 'MOD' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:37:7: 'MOD'
			{
			DebugLocation(37, 7);
			Match("MOD"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("MOD", 23);
			LeaveRule("MOD", 23);
			LeaveRule_MOD();
		}
	}
	// $ANTLR end "MOD"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 24);
		TraceIn("NOT", 24);
		try
		{
			int _type = NOT;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:38:5: ( '!' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:38:7: '!'
			{
			DebugLocation(38, 7);
			Match('!'); 

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("NOT", 24);
			LeaveRule("NOT", 24);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 25);
		TraceIn("AND", 25);
		try
		{
			int _type = AND;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:39:5: ( 'AND' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:39:7: 'AND'
			{
			DebugLocation(39, 7);
			Match("AND"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("AND", 25);
			LeaveRule("AND", 25);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 26);
		TraceIn("OR", 26);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:40:4: ( 'OR' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:40:6: 'OR'
			{
			DebugLocation(40, 6);
			Match("OR"); 


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("OR", 26);
			LeaveRule("OR", 26);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_LETTER();
	partial void LeaveRule_LETTER();

	// $ANTLR start "LETTER"
	[GrammarRule("LETTER")]
	private void mLETTER()
	{
		EnterRule_LETTER();
		EnterRule("LETTER", 27);
		TraceIn("LETTER", 27);
		try
		{
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:45:9: ( ( 'A' .. 'Z' ) )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:
			{
			DebugLocation(45, 9);
			if ((input.LA(1)>='A' && input.LA(1)<='Z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("LETTER", 27);
			LeaveRule("LETTER", 27);
			LeaveRule_LETTER();
		}
	}
	// $ANTLR end "LETTER"

	partial void EnterRule_LETTERL();
	partial void LeaveRule_LETTERL();

	// $ANTLR start "LETTERL"
	[GrammarRule("LETTERL")]
	private void mLETTERL()
	{
		EnterRule_LETTERL();
		EnterRule("LETTERL", 28);
		TraceIn("LETTERL", 28);
		try
		{
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:47:9: ( ( 'a' .. 'z' ) )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:
			{
			DebugLocation(47, 9);
			if ((input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("LETTERL", 28);
			LeaveRule("LETTERL", 28);
			LeaveRule_LETTERL();
		}
	}
	// $ANTLR end "LETTERL"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 29);
		TraceIn("DIGIT", 29);
		try
		{
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:49:9: ( '0' .. '9' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:
			{
			DebugLocation(49, 9);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("DIGIT", 29);
			LeaveRule("DIGIT", 29);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_ID();
	partial void LeaveRule_ID();

	// $ANTLR start "ID"
	[GrammarRule("ID")]
	private void mID()
	{
		EnterRule_ID();
		EnterRule("ID", 30);
		TraceIn("ID", 30);
		try
		{
			int _type = ID;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:50:9: ( LETTER ( LETTER | DIGIT | '_' )* )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:50:17: LETTER ( LETTER | DIGIT | '_' )*
			{
			DebugLocation(50, 17);
			mLETTER(); 
			DebugLocation(50, 24);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:50:24: ( LETTER | DIGIT | '_' )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>='0' && LA1_1<='9')||(LA1_1>='A' && LA1_1<='Z')||LA1_1=='_'))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:
					{
					DebugLocation(50, 24);
					input.Consume();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("ID", 30);
			LeaveRule("ID", 30);
			LeaveRule_ID();
		}
	}
	// $ANTLR end "ID"

	partial void EnterRule_NAME();
	partial void LeaveRule_NAME();

	// $ANTLR start "NAME"
	[GrammarRule("NAME")]
	private void mNAME()
	{
		EnterRule_NAME();
		EnterRule("NAME", 31);
		TraceIn("NAME", 31);
		try
		{
			int _type = NAME;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:51:6: ( ( LETTERL | '_' ) ( LETTERL | DIGIT | '_' )* )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:51:8: ( LETTERL | '_' ) ( LETTERL | DIGIT | '_' )*
			{
			DebugLocation(51, 8);
			if (input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(51, 23);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:51:23: ( LETTERL | DIGIT | '_' )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if (((LA2_1>='0' && LA2_1<='9')||LA2_1=='_'||(LA2_1>='a' && LA2_1<='z')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:
					{
					DebugLocation(51, 23);
					input.Consume();


					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("NAME", 31);
			LeaveRule("NAME", 31);
			LeaveRule_NAME();
		}
	}
	// $ANTLR end "NAME"

	partial void EnterRule_NUMBER();
	partial void LeaveRule_NUMBER();

	// $ANTLR start "NUMBER"
	[GrammarRule("NUMBER")]
	private void mNUMBER()
	{
		EnterRule_NUMBER();
		EnterRule("NUMBER", 32);
		TraceIn("NUMBER", 32);
		try
		{
			int _type = NUMBER;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:52:9: ( ( PLUS | MINUS )? ( DIGIT )+ )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:52:17: ( PLUS | MINUS )? ( DIGIT )+
			{
			DebugLocation(52, 17);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:52:17: ( PLUS | MINUS )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1=='+'||LA3_1=='-'))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:
				{
				DebugLocation(52, 17);
				input.Consume();


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(52, 33);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:52:33: ( DIGIT )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if (((LA4_1>='0' && LA4_1<='9')))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:
					{
					DebugLocation(52, 33);
					input.Consume();


					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("NUMBER", 32);
			LeaveRule("NUMBER", 32);
			LeaveRule_NUMBER();
		}
	}
	// $ANTLR end "NUMBER"

	partial void EnterRule_COMMENT();
	partial void LeaveRule_COMMENT();

	// $ANTLR start "COMMENT"
	[GrammarRule("COMMENT")]
	private void mCOMMENT()
	{
		EnterRule_COMMENT();
		EnterRule("COMMENT", 33);
		TraceIn("COMMENT", 33);
		try
		{
			int _type = COMMENT;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:53:9: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:53:17: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
			{
			DebugLocation(53, 17);
			Match("//"); 

			DebugLocation(53, 22);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:53:22: (~ ( '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if (((LA5_1>='\u0000' && LA5_1<='\t')||(LA5_1>='\u000B' && LA5_1<='\f')||(LA5_1>='\u000E' && LA5_1<='\uFFFF')))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:
					{
					DebugLocation(53, 22);
					input.Consume();


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(53, 36);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:53:36: ( '\\r' )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1=='\r'))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:53:36: '\\r'
				{
				DebugLocation(53, 36);
				Match('\r'); 

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(53, 42);
			Match('\n'); 
			DebugLocation(53, 47);
			_channel=Hidden;

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("COMMENT", 33);
			LeaveRule("COMMENT", 33);
			LeaveRule_COMMENT();
		}
	}
	// $ANTLR end "COMMENT"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 34);
		TraceIn("WS", 34);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:54:9: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:54:17: ( ' ' | '\\t' | '\\r' | '\\n' )
			{
			DebugLocation(54, 17);
			if ((input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(54, 46);
			_channel=Hidden;

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("WS", 34);
			LeaveRule("WS", 34);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	partial void EnterRule_STRING();
	partial void LeaveRule_STRING();

	// $ANTLR start "STRING"
	[GrammarRule("STRING")]
	private void mSTRING()
	{
		EnterRule_STRING();
		EnterRule("STRING", 35);
		TraceIn("STRING", 35);
		try
		{
			int _type = STRING;
			int _channel = DefaultTokenChannel;
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:55:9: ( QUOTE ( options {greedy=false; } : . )+ QUOTE )
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:55:17: QUOTE ( options {greedy=false; } : . )+ QUOTE
			{
			DebugLocation(55, 17);
			mQUOTE(); 
			DebugLocation(55, 23);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:55:23: ( options {greedy=false; } : . )+
			int cnt7=0;
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1=='\"'))
				{
					alt7 = 2;
				}
				else if (((LA7_1>='\u0000' && LA7_1<='!')||(LA7_1>='#' && LA7_1<='\uFFFF')))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:55:51: .
					{
					DebugLocation(55, 51);
					MatchAny(); 

					}
					break;

				default:
					if (cnt7 >= 1)
						goto loop7;

					EarlyExitException eee7 = new EarlyExitException( 7, input );
					DebugRecognitionException(eee7);
					throw eee7;
				}
				cnt7++;
			}
			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(55, 56);
			mQUOTE(); 

			}

			state.type = _type;
			state.channel = _channel;
        }
        catch (MismatchedTokenException e) { }
		finally
		{
			TraceOut("STRING", 35);
			LeaveRule("STRING", 35);
			LeaveRule_STRING();
		}
	}
	// $ANTLR end "STRING"

	public override void mTokens()
	{
		// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:8: ( PLUS | MINUS | MUL | LPAREN | RPAREN | SEMI | BECOMES | EQL | NEQ | LEQ | GEQ | COM | QUOTE | PROG | START | VAR | STOP | GET | PUT | REP | UNT | DIV | MOD | NOT | AND | OR | ID | NAME | NUMBER | COMMENT | WS | STRING )
		int alt8=32;
		try { DebugEnterDecision(8, false);
		try
		{
			alt8 = dfa8.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(8); }
		switch (alt8)
		{
		case 1:
			DebugEnterAlt(1);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:10: PLUS
			{
			DebugLocation(1, 10);
			mPLUS(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:15: MINUS
			{
			DebugLocation(1, 15);
			mMINUS(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:21: MUL
			{
			DebugLocation(1, 21);
			mMUL(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:25: LPAREN
			{
			DebugLocation(1, 25);
			mLPAREN(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:32: RPAREN
			{
			DebugLocation(1, 32);
			mRPAREN(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:39: SEMI
			{
			DebugLocation(1, 39);
			mSEMI(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:44: BECOMES
			{
			DebugLocation(1, 44);
			mBECOMES(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:52: EQL
			{
			DebugLocation(1, 52);
			mEQL(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:56: NEQ
			{
			DebugLocation(1, 56);
			mNEQ(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:60: LEQ
			{
			DebugLocation(1, 60);
			mLEQ(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:64: GEQ
			{
			DebugLocation(1, 64);
			mGEQ(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:68: COM
			{
			DebugLocation(1, 68);
			mCOM(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:72: QUOTE
			{
			DebugLocation(1, 72);
			mQUOTE(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:78: PROG
			{
			DebugLocation(1, 78);
			mPROG(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:83: START
			{
			DebugLocation(1, 83);
			mSTART(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:89: VAR
			{
			DebugLocation(1, 89);
			mVAR(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:93: STOP
			{
			DebugLocation(1, 93);
			mSTOP(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:98: GET
			{
			DebugLocation(1, 98);
			mGET(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:102: PUT
			{
			DebugLocation(1, 102);
			mPUT(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:106: REP
			{
			DebugLocation(1, 106);
			mREP(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:110: UNT
			{
			DebugLocation(1, 110);
			mUNT(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:114: DIV
			{
			DebugLocation(1, 114);
			mDIV(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:118: MOD
			{
			DebugLocation(1, 118);
			mMOD(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:122: NOT
			{
			DebugLocation(1, 122);
			mNOT(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:126: AND
			{
			DebugLocation(1, 126);
			mAND(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:130: OR
			{
			DebugLocation(1, 130);
			mOR(); 

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:133: ID
			{
			DebugLocation(1, 133);
			mID(); 

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:136: NAME
			{
			DebugLocation(1, 136);
			mNAME(); 

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:141: NUMBER
			{
			DebugLocation(1, 141);
			mNUMBER(); 

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:148: COMMENT
			{
			DebugLocation(1, 148);
			mCOMMENT(); 

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:156: WS
			{
			DebugLocation(1, 156);
			mWS(); 

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// D:\\Projects C#\\SP_Test\\SP_Test\\Y11.g:1:159: STRING
			{
			DebugLocation(1, 159);
			mSTRING(); 

			}
			break;

		}

	}


	#region DFA
	DFA8 dfa8;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa8 = new DFA8(this, SpecialStateTransition8);
	}

	private class DFA8 : DFA
	{
		private const string DFA8_eotS =
			"\x1\xFFFF\x1\x1E\x1\x1F\x9\xFFFF\x1\x22\x1\xFFFF\x8\x19\x1\xFFFF\x2\x19"+
			"\xB\xFFFF\x9\x19\x1\x38\x3\x19\x1\x3C\x1\x3D\x2\x19\x1\x40\x1\x41\x1"+
			"\x42\x1\xFFFF\x1\x19\x1\x44\x1\x19\x2\xFFFF\x2\x19\x3\xFFFF\x1\x48\x1"+
			"\xFFFF\x2\x19\x1\x4B\x1\xFFFF\x1\x19\x1\x4D\x1\xFFFF\x1\x19\x1\xFFFF"+
			"\x1\x4F\x1\xFFFF";
		private const string DFA8_eofS =
			"\x50\xFFFF";
		private const string DFA8_minS =
			"\x1\x9\x2\x30\x6\xFFFF\x1\x3D\x2\xFFFF\x1\x0\x1\xFFFF\x1\x54\x1\x41\x1"+
			"\x45\x1\x55\x1\x45\x1\x4E\x1\x49\x1\x4F\x1\xFFFF\x1\x4E\x1\x52\xB\xFFFF"+
			"\x1\x41\x1\x52\x2\x54\x1\x50\x1\x54\x1\x56\x2\x44\x1\x30\x1\x52\x1\x50"+
			"\x1\x49\x2\x30\x1\x45\x1\x49\x3\x30\x1\xFFFF\x1\x54\x1\x30\x1\x41\x2"+
			"\xFFFF\x1\x41\x1\x4C\x3\xFFFF\x1\x30\x1\xFFFF\x1\x42\x1\x54\x1\x30\x1"+
			"\xFFFF\x1\x4C\x1\x30\x1\xFFFF\x1\x45\x1\xFFFF\x1\x30\x1\xFFFF";
		private const string DFA8_maxS =
			"\x1\x7A\x2\x39\x6\xFFFF\x1\x3E\x2\xFFFF\x1\xFFFF\x1\xFFFF\x1\x54\x1\x41"+
			"\x1\x45\x1\x55\x1\x45\x1\x4E\x1\x49\x1\x4F\x1\xFFFF\x1\x4E\x1\x52\xB"+
			"\xFFFF\x1\x4F\x1\x52\x2\x54\x1\x50\x1\x54\x1\x56\x2\x44\x1\x5F\x1\x52"+
			"\x1\x50\x1\x49\x2\x5F\x1\x45\x1\x49\x3\x5F\x1\xFFFF\x1\x54\x1\x5F\x1"+
			"\x41\x2\xFFFF\x1\x41\x1\x4C\x3\xFFFF\x1\x5F\x1\xFFFF\x1\x42\x1\x54\x1"+
			"\x5F\x1\xFFFF\x1\x4C\x1\x5F\x1\xFFFF\x1\x45\x1\xFFFF\x1\x5F\x1\xFFFF";
		private const string DFA8_acceptS =
			"\x3\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\xFFFF\x1\xB\x1\xC\x1"+
			"\xFFFF\x1\xE\x8\xFFFF\x1\x18\x2\xFFFF\x1\x1B\x1\x1C\x1\x1D\x1\x1E\x1"+
			"\x1F\x1\x1\x1\x2\x1\x9\x1\xA\x1\xD\x1\x20\x14\xFFFF\x1\x1A\x3\xFFFF\x1"+
			"\x12\x1\x13\x2\xFFFF\x1\x16\x1\x17\x1\x19\x1\xFFFF\x1\x11\x3\xFFFF\x1"+
			"\xF\x2\xFFFF\x1\x15\x1\xFFFF\x1\x14\x1\xFFFF\x1\x10";
		private const string DFA8_specialS =
			"\xC\xFFFF\x1\x0\x43\xFFFF}>";
		private static readonly string[] DFA8_transitionS =
			{
				"\x2\x1D\x2\xFFFF\x1\x1D\x12\xFFFF\x1\x1D\x1\x16\x1\xC\x1\xD\x4\xFFFF"+
				"\x1\x4\x1\x5\x1\x3\x1\x1\x1\xB\x1\x2\x1\xFFFF\x1\x1C\xA\x1B\x1\x7\x1"+
				"\x6\x1\x9\x1\x8\x1\xA\x2\xFFFF\x1\x17\x2\x19\x1\x14\x2\x19\x1\x10\x5"+
				"\x19\x1\x15\x1\x19\x1\x18\x1\x11\x1\x19\x1\x12\x1\xE\x1\x19\x1\x13\x1"+
				"\xF\x4\x19\x4\xFFFF\x1\x1A\x1\xFFFF\x1A\x1A",
				"\xA\x1B",
				"\xA\x1B",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x21\x1\x20",
				"",
				"",
				"\x0\x23",
				"",
				"\x1\x24",
				"\x1\x25",
				"\x1\x26",
				"\x1\x27",
				"\x1\x28",
				"\x1\x29",
				"\x1\x2A",
				"\x1\x2B",
				"",
				"\x1\x2C",
				"\x1\x2D",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x2E\xD\xFFFF\x1\x2F",
				"\x1\x30",
				"\x1\x31",
				"\x1\x32",
				"\x1\x33",
				"\x1\x34",
				"\x1\x35",
				"\x1\x36",
				"\x1\x37",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"\x1\x39",
				"\x1\x3A",
				"\x1\x3B",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"\x1\x3E",
				"\x1\x3F",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"",
				"\x1\x43",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"\x1\x45",
				"",
				"",
				"\x1\x46",
				"\x1\x47",
				"",
				"",
				"",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"",
				"\x1\x49",
				"\x1\x4A",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"",
				"\x1\x4C",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				"",
				"\x1\x4E",
				"",
				"\xA\x19\x7\xFFFF\x1A\x19\x4\xFFFF\x1\x19",
				""
			};

		private static readonly short[] DFA8_eot = DFA.UnpackEncodedString(DFA8_eotS);
		private static readonly short[] DFA8_eof = DFA.UnpackEncodedString(DFA8_eofS);
		private static readonly char[] DFA8_min = DFA.UnpackEncodedStringToUnsignedChars(DFA8_minS);
		private static readonly char[] DFA8_max = DFA.UnpackEncodedStringToUnsignedChars(DFA8_maxS);
		private static readonly short[] DFA8_accept = DFA.UnpackEncodedString(DFA8_acceptS);
		private static readonly short[] DFA8_special = DFA.UnpackEncodedString(DFA8_specialS);
		private static readonly short[][] DFA8_transition;

		static DFA8()
		{
			int numStates = DFA8_transitionS.Length;
			DFA8_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA8_transition[i] = DFA.UnpackEncodedString(DFA8_transitionS[i]);
			}
		}

		public DFA8( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 8;
			this.eot = DFA8_eot;
			this.eof = DFA8_eof;
			this.min = DFA8_min;
			this.max = DFA8_max;
			this.accept = DFA8_accept;
			this.special = DFA8_special;
			this.transition = DFA8_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( PLUS | MINUS | MUL | LPAREN | RPAREN | SEMI | BECOMES | EQL | NEQ | LEQ | GEQ | COM | QUOTE | PROG | START | VAR | STOP | GET | PUT | REP | UNT | DIV | MOD | NOT | AND | OR | ID | NAME | NUMBER | COMMENT | WS | STRING );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition8(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		s = -1;
		int LA8_1 = input.LA(1);
		int index8_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				if (((LA8_1>='\u0000' && LA8_1<='\uFFFF'))) {s = 35;}

				else s = 34;

				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		NoViableAltException nvae = new NoViableAltException(dfa.Description, 8, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion

}

} // namespace Y11
